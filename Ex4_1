#include <iostream>
#include <stdexcept>
using namespace std;

class Fraction {
private:
    int numerator;
    int denominator;

    // Rút gọn phân số bằng GCD
    void simplify() {
        int a = abs(numerator), b = abs(denominator);
        while (b != 0) {
            int t = a % b;
            a = b;
            b = t;
        }
        if (a != 0) {
            numerator /= a;
            denominator /= a;
        }
        if (denominator < 0) { // chuẩn hóa dấu
            numerator = -numerator;
            denominator = -denominator;
        }
    }

public:
    // Constructor
    Fraction(int num = 0, int den = 1) {
        if (den == 0) throw invalid_argument("Denominator cannot be zero");
        numerator = num;
        denominator = den;
        simplify();
    }

    // Copy constructor
    Fraction(const Fraction& other) {
        numerator = other.numerator;
        denominator = other.denominator;
    }


    // Arithmetic Operators

    Fraction operator+(const Fraction& other) const {
        return Fraction(numerator * other.denominator + other.numerator * denominator,
                        denominator * other.denominator);
    }

    Fraction operator-(const Fraction& other) const {
        return Fraction(numerator * other.denominator - other.numerator * denominator,
                        denominator * other.denominator);
    }

    Fraction operator*(const Fraction& other) const {
        return Fraction(numerator * other.numerator, denominator * other.denominator);
    }

    Fraction operator/(const Fraction& other) const {
        if (other.numerator == 0)
            throw invalid_argument("Division by zero fraction");
        return Fraction(numerator * other.denominator, denominator * other.numerator);
    }


    // Comparison Operators

    bool operator==(const Fraction& other) const {
        return numerator == other.numerator && denominator == other.denominator;
    }
    bool operator!=(const Fraction& other) const { return !(*this == other); }
    bool operator>(const Fraction& other) const {
        return (numerator * other.denominator > other.numerator * denominator);
    }
    bool operator<(const Fraction& other) const { return other > *this; }
    bool operator>=(const Fraction& other) const { return !(*this < other); }
    bool operator<=(const Fraction& other) const { return !(*this > other); }


    // Assignment Operators
    Fraction& operator=(const Fraction& other) {
        if (this != &other) {
            numerator = other.numerator;
            denominator = other.denominator;
        }
        return *this;
    }

    Fraction& operator+=(const Fraction& other) {
        *this = *this + other;
        return *this;
    }

    Fraction& operator*=(const Fraction& other) {
        *this = *this * other;
        return *this;
    }



    // Increment / Decrement
    // Prefix ++
    Fraction& operator++() {
        numerator += denominator;
        simplify();
        return *this;
    }

    // Postfix ++
    Fraction operator++(int) {
        Fraction temp = *this;
        ++(*this);
        return temp;
    }

    // Prefix --
    Fraction& operator--() {
        numerator -= denominator;
        simplify();
        return *this;
    }

    // Postfix --
    Fraction operator--(int) {
        Fraction temp = *this;
        --(*this);
        return temp;
    }


    // Type-cast Operators
    operator float() const { return (float)numerator / denominator; }
    operator int() const { return numerator / denominator; }


    // Input / Output
    friend ostream& operator<<(ostream& os, const Fraction& f) {
        os << f.numerator;
        if (f.denominator != 1)
            os << "/" << f.denominator;
        return os;
    }

    friend istream& operator>>(istream& is, Fraction& f) {
        char slash;
        is >> f.numerator;
        if (is.peek() == '/') {
            is >> slash >> f.denominator;
        } else {
            f.denominator = 1;
        }
        f.simplify();
        return is;
    }
};
